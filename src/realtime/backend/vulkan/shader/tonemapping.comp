#version 460

#define LOCAL_SIZE_X 16
#define LOCAL_SIZE_Y 16
#define LOCAL_SIZE_Z 1

vec3 Tonemap_ACES(const vec3 c)
{
	// Narkowicz 2015, "ACES Filmic Tone Mapping Curve"
	// const float a = 2.51;
	// const float b = 0.03;
	// const float c = 2.43;
	// const float d = 0.59;
	// const float e = 0.14;
	// return saturate((x*(a*x+b))/(x*(c*x+d)+e));

	// ACES RRT/ODT curve fit courtesy of Stephen Hill
	vec3 a = c * (c + 0.0245786) - 0.000090537;
	vec3 b = c * (0.983729 * c + 0.4329510) + 0.238081;
	return a / b;
}
layout(set = 0, binding = 0) uniform Uniform
{
	uint width;
	uint height;
	uint enableTonemapping;
}
imageInfo;

// TODO: generate image format dynamically
layout(set = 1, binding = 0, rgba8) uniform readonly image2D InputImage;
layout(set = 1, binding = 1, rgba8) uniform writeonly image2D OutputImage;

layout(local_size_x = LOCAL_SIZE_X, local_size_y = LOCAL_SIZE_Y, local_size_z = LOCAL_SIZE_Z) in;

void main()
{
	ivec2 index = ivec2(gl_GlobalInvocationID.xy);
	const uint rowBegin = index.y * LOCAL_SIZE_Y;
	const uint rowEnd = min(rowBegin + LOCAL_SIZE_Y, imageInfo.height);
	const uint colBegin = index.x * LOCAL_SIZE_X;
	const uint colEnd = min(colBegin + LOCAL_SIZE_X, imageInfo.width);
	if (imageInfo.enableTonemapping == 1) {
		for (uint row = rowBegin; row < rowEnd; ++row) {
			for (uint col = colBegin; col < colEnd; ++col) {
				const vec4 inColor = imageLoad(InputImage, ivec2(row, col));
				imageStore(OutputImage, ivec2(row, col),
						   vec4(Tonemap_ACES(inColor.rgb), inColor.a));
			}
		}
	}
	else {
		for (uint row = rowBegin; row < rowEnd; ++row) {
			for (uint col = colBegin; col < colEnd; ++col) {
				const vec4 inColor = imageLoad(InputImage, ivec2(row, col));
				imageStore(OutputImage, ivec2(row, col), inColor);
			}
		}
	}
}